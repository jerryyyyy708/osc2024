#include "sd_driver.h"
#include "vfs.h"
#include "tmpfs.h"
#include "memory.h"
#include "shell.h"
#include "utils.h"
#include <stdint.h>

extern char* cpio_base;

struct PartitionEntry {
    uint8_t status;
    uint8_t start_head;
    uint16_t start_sector_cylinder;
    uint8_t type;
    uint8_t end_head;
    uint16_t end_sector_cylinder;
    uint32_t start_lba;
    uint32_t size_in_sectors;
} __attribute__((packed));

struct FAT32BootSector {
    uint8_t jump_boot[3];
    uint8_t oem_name[8];
    uint16_t bytes_per_sector;
    uint8_t sectors_per_cluster;
    uint16_t reserved_sector_count;
    uint8_t num_fats;
    uint16_t root_entry_count;
    uint16_t total_sectors_16;
    uint8_t media;
    uint16_t fat_size_16;
    uint16_t sectors_per_track;
    uint16_t num_heads;
    uint32_t hidden_sectors;
    uint32_t total_sectors_32;
    uint32_t fat_size_32;
    uint16_t ext_flags;
    uint16_t fs_version;
    uint32_t root_cluster;
    uint16_t fs_info;
    uint16_t backup_boot_sector;
    uint8_t reserved[12];
    uint8_t drive_number;
    uint8_t reserved1;
    uint8_t boot_signature;
    uint32_t volume_id;
    uint8_t volume_label[11];
    uint8_t fs_type[8];
} __attribute__((packed));

struct fat32_mbr {
    char boot_code[446];
    struct PartitionEntry partitions[4];
    uint16_t signature;
} __attribute__((packed));

struct DirectoryEntry {
    uint8_t name[11];
    uint8_t attr;
    uint8_t nt_res;
    uint8_t crt_time_tenth;
    uint16_t crt_time;
    uint16_t crt_date;
    uint16_t lst_acc_date;
    uint16_t fst_clus_hi;
    uint16_t wrt_time;
    uint16_t wrt_date;
    uint16_t fst_clus_lo;
    uint32_t file_size;
} __attribute__((packed));

char* memcpy(void *dest, const void *src, unsigned long long len)
{
    char *d = dest;
    const char *s = src;
    while (len--)
        *d++ = *s++;
    return dest;
}

void format_filename(char *dest, const char *src) {
    int i, j;
    for (i = 0, j = 0; i < 11; i++) {
        if (i == 8) {
            dest[j++] = '.';  // 插入檔案名與擴展名之間的點
        }
        if (src[i] != ' ') {
            dest[j++] = src[i];
        }
    }
    dest[j] = '\0';  // 結尾字符
}

int fat32_mount(struct filesystem *_fs, struct mount *mt){
    mt->fs = _fs;
    char buf[512];
    readblock(0, buf);
    struct fat32_mbr *mbr = (struct fat32_mbr *)buf;

    // Assume partition 1 is FAT32 for simplicity
    struct PartitionEntry *partition = &mbr->partitions[0];
    if(partition->type != 0xB && partition->type != 0xC) { // Check for FAT32 partition type
        uart_puts("Not a FAT32 partition.\n");
        return -1;
    }

    int fat_start_block = partition->start_lba;
    readblock(fat_start_block, buf); // Read the first block of the partition
    struct FAT32BootSector *boot_sector = (struct FAT32BootSector *)buf;

    int root_dir_start_block = fat_start_block + ((boot_sector->reserved_sector_count + (boot_sector->num_fats * boot_sector->fat_size_32)) * boot_sector->sectors_per_cluster);
    uart_int(root_dir_start_block);
    newline();
    readblock(root_dir_start_block, buf);

    struct DirectoryEntry *dir = (struct DirectoryEntry *)buf;
    char formatted_name[13]; // 8 字元名稱 + 1 點 + 3 擴展名 + 1 結尾

    for (int i = 0; i < 16; i++) {  // 假定每個塊有 16 個條目
        if (dir[i].name[0] == 0x00) break; // 結束目錄讀取
        if (dir[i].name[0] == 0xE5) continue; // 跳過已刪除文件
        if (dir[i].attr & 0x08) continue; // 跳過卷標

        format_filename(formatted_name, dir[i].name);
        if (dir[i].attr & 0x10) {  // 目錄條目
            uart_puts("[DIR] ");
            uart_puts(formatted_name);
            newline();
        } else {  // 文件條目
            uart_puts("[FILE] ");
            uart_puts(formatted_name);
            newline();
        }
    }
    return 0;
}


int reg_fat32(){
    struct filesystem fs;
    fs.name = "fat32";
    fs.setup_mount = fat32_mount;
    return register_filesystem(&fs);
}
